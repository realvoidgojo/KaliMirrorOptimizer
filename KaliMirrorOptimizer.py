#!/usr/bin/python3
import requests
import re
import argparse
import subprocess
from concurrent.futures import ThreadPoolExecutor
from shutil import copyfile
import os
import sys

# Headers for requests
HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36'
}

def fetch_mirrors():
    """Fetch mirror list from Kali's official page."""
    try:
        response = requests.get('https://http.kali.org/README.mirrorlist', headers=HEADERS)
        response.raise_for_status()
        return set(re.findall(r'https?://[^\s"]+', response.text))
    except requests.exceptions.RequestException as e:
        sys.exit(f"[!] Failed to fetch mirrors: {e}")

def check_latency(host):
    """Ping a host and return the average latency."""
    try:
        result = subprocess.run(
            ['ping', '-c', '3', host],
            text=True,
            capture_output=True,
            check=True
        )
        if "100% packet loss" in result.stdout:
            return float('inf')
        latency = result.stdout.splitlines()[-1].split('=')[-1].split('/')[1]
        return float(latency)
    except subprocess.CalledProcessError:
        return float('inf')

def find_best_mirror(mirrors, https):
    """Find the fastest mirror by pinging them."""
    schema = "https://" if https else "http://"
    hosts = [url.split("//")[-1].split("/")[0] for url in mirrors]
    latencies = {}

    with ThreadPoolExecutor() as executor:
        results = executor.map(check_latency, hosts)
        for host, latency in zip(hosts, results):
            if latency != float('inf'):
                latencies[host] = latency

    if not latencies:
        sys.exit("[!] No responsive mirrors found.")
    
    best_host = min(latencies, key=latencies.get)
    return f"{schema}{best_host}/kali"

def backup_sources_list():
    """Backup the current sources.list."""
    backup_file = "/etc/apt/sources.list.bk"
    if not os.path.exists(backup_file):
        copyfile('/etc/apt/sources.list', backup_file)
        print("[+] Backup created at /etc/apt/sources.list.bk")

def update_sources_list(new_mirror, sources):
    """Update sources.list with the best mirror."""
    try:
        with open("/etc/apt/sources.list", "w") as f:
            f.write("# Autogenerated script by MirrorScripts-V2\n")
            f.write(f"deb {new_mirror} kali-rolling main contrib non-free\n")
            if sources:
                f.write(f"deb-src {new_mirror} kali-rolling main contrib non-free\n")
        print("[+] Updated sources.list with the best mirror.")
    except Exception as e:
        sys.exit(f"[!] Failed to update sources.list: {e}")

def main():
    # Argument parsing
    parser = argparse.ArgumentParser(
        description='Automatically select the best Kali mirror and apply the configuration.'
    )
    parser.add_argument('-v', '--verbose', help='enable verbose output', action="store_true")
    parser.add_argument('-https', help='use HTTPS in apt transport (default HTTP)', action="store_true")
    parser.add_argument('-src', help='enable sources packages (default disable)', action="store_true")
    args = parser.parse_args()

    if os.getuid() != 0:
        sys.exit("[!] Must run as root/sudo.")

    verbose = args.verbose
    https = args.https
    sources = args.src

    if verbose:
        print("[+] Fetching mirrors...")

    mirrors = fetch_mirrors()

    if verbose:
        print(f"[+] Found {len(mirrors)} mirrors.")

    if verbose:
        print("[+] Finding the best mirror...")
    
    best_mirror = find_best_mirror(mirrors, https)

    if verbose:
        print(f"[+] Best mirror: {best_mirror}")

    print("[+] Backing up sources.list...")
    backup_sources_list()

    print("[+] Updating sources.list...")
    update_sources_list(best_mirror, sources)

    print("[+] Done! Run 'sudo apt clean; sudo apt update' to apply changes.")

if __name__ == "__main__":
    main()
