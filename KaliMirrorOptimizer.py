#!/usr/bin/python3
import requests
import re
import argparse
import subprocess
from concurrent.futures import ThreadPoolExecutor
from shutil import copyfile
import os
import sys

# Headers for requests
HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36'
}

VALID_MIRROR_DOMAINS = [
    "kali.org", "mirrorservice.org", "karnelval.cz", "rwth-aachen.de",
    "nluug.nl", "dotsrc.org", "ftp.acc.umu.se", "mirrors.ocf.berkeley.edu"
]

def fetch_mirrors():
    """Fetch mirror list from Kali's official page."""
    try:
        print("[+] Fetching mirrors list from Kali official repository...")
        response = requests.get('https://http.kali.org/README.mirrorlist', headers=HEADERS)
        response.raise_for_status()  # Will raise HTTPError if the response was an error
        mirrors = set(re.findall(r'https?://[^\s"]+', response.text))
        # Filter mirrors to ensure only valid domains are included
        valid_mirrors = {url for url in mirrors if any(domain in url for domain in VALID_MIRROR_DOMAINS)}
        if not valid_mirrors:
            sys.exit("[!] No valid mirrors found.")
        print(f"[+] Found {len(valid_mirrors)} valid mirrors.")
        return valid_mirrors
    except requests.exceptions.RequestException as e:
        sys.exit(f"[!] Failed to fetch mirrors: {e}")

def check_mirror(mirror_url):
    """Check if the mirror URL is valid by sending a request to a known endpoint."""
    try:
        print(f"[+] Checking mirror: {mirror_url}")
        response = requests.get(f"{mirror_url}/dists/kali-rolling/Release", headers=HEADERS, timeout=5)
        if response.status_code == 200:
            print(f"[+] Mirror {mirror_url} is valid.")
            return True
        else:
            print(f"[-] Mirror {mirror_url} is invalid or inaccessible (HTTP {response.status_code}).")
            return False
    except requests.exceptions.RequestException:
        print(f"[-] Mirror {mirror_url} is unreachable or invalid.")
        return False

def check_latency(host):
    """Ping a host and return the average latency."""
    try:
        print(f"[+] Checking latency for {host}...")
        result = subprocess.run(
            ['ping', '-c', '3', host],
            text=True,
            capture_output=True,
            check=True
        )
        if "100% packet loss" in result.stdout:
            print(f"[-] Host {host} is unreachable.")
            return float('inf')
        latency = result.stdout.splitlines()[-1].split('=')[-1].split('/')[1]
        print(f"[+] Latency for {host}: {latency} ms")
        return float(latency)
    except subprocess.CalledProcessError:
        print(f"[-] Failed to ping {host}.")
        return float('inf')

def find_best_mirror(mirrors, https):
    """Find the fastest mirror by pinging them."""
    schema = "https://" if https else "http://"
    hosts = [url.split("//")[-1].split("/")[0] for url in mirrors]
    latencies = {}

    # Check the mirrors for validity first
    valid_mirrors = [mirror for mirror in mirrors if check_mirror(mirror)]

    if not valid_mirrors:
        sys.exit("[!] No valid mirrors found after checking.")

    # Find the best mirror based on latency
    with ThreadPoolExecutor() as executor:
        print("[+] Pinging mirrors to find the best one...")
        results = executor.map(check_latency, [url.split("//")[-1].split("/")[0] for url in valid_mirrors])
        for host, latency in zip(valid_mirrors, results):
            if latency != float('inf'):
                latencies[host] = latency

    if not latencies:
        sys.exit("[!] No responsive mirrors found.")
    
    best_mirror = min(latencies, key=latencies.get)
    print(f"[+] Best mirror selected: {best_mirror}")
    return best_mirror

def backup_sources_list():
    """Backup the current sources.list."""
    try:
        backup_file = "/etc/apt/sources.list.bk"
        if not os.path.exists(backup_file):
            copyfile('/etc/apt/sources.list', backup_file)
            print("[+] Backup created at /etc/apt/sources.list.bk")
        else:
            print("[+] Backup already exists, skipping backup.")
    except Exception as e:
        sys.exit(f"[!] Failed to backup sources.list: {e}")

def update_sources_list(new_mirror, sources):
    """Update sources.list with the best mirror."""
    try:
        print(f"[+] Updating /etc/apt/sources.list with the new mirror: {new_mirror}...")
        with open("/etc/apt/sources.list", "w") as f:
            f.write("# Autogenerated script by MirrorScripts-V2\n")
            f.write(f"deb {new_mirror} kali-rolling main contrib non-free\n")
            if sources:
                f.write(f"deb-src {new_mirror} kali-rolling main contrib non-free\n")
        print("[+] /etc/apt/sources.list updated successfully.")
    except Exception as e:
        sys.exit(f"[!] Failed to update sources.list: {e}")

def main():
    # Argument parsing
    parser = argparse.ArgumentParser(
        description='Automatically select the best Kali mirror and apply the configuration.'
    )
    parser.add_argument('-v', '--verbose', help='enable verbose output', action="store_true")
    parser.add_argument('-https', help='use HTTPS in apt transport (default HTTP)', action="store_true")
    parser.add_argument('-src', help='enable sources packages (default disable)', action="store_true")
    args = parser.parse_args()

    if os.getuid() != 0:
        sys.exit("[!] Must run as root/sudo.")

    verbose = args.verbose
    https = args.https
    sources = args.src

    if verbose:
        print("[+] Starting script execution...")

    mirrors = fetch_mirrors()

    if verbose:
        print(f"[+] Found {len(mirrors)} mirrors.")

    best_mirror = find_best_mirror(mirrors, https)

    if verbose:
        print(f"[+] Best mirror: {best_mirror}")

    print("[+] Backing up sources.list...")
    backup_sources_list()

    print("[+] Updating sources.list...")
    update_sources_list(best_mirror, sources)

    print("[+] Done! Run 'sudo apt clean; sudo apt update' to apply changes.")

if __name__ == "__main__":
    main()
